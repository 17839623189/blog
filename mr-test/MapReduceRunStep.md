我们可以将一个MapReduce作业的运行过程简单的拆分成6个过程，分别是作业的提交、作业初始化、任务分配、任务执行、进度和状态的更新、作业完成。下面我就一起来具体了解下这么几个步骤。
### 作业的提交
当我们调用job.submit()或者job.waitForCompletion()方法（其内部也会调用submit()方法）的时候，会创建一个JobSubmitter对象，在JobSubmitter内部所实现的作业提交过程如下：
1. 像资源管理器请求新的应用ID作为MapReduce作业的作业ID。
2. 检查作业的输出目录，如果没有指定输出目录或者输出目录已经存在就会抛出错误，这也就是为啥我们在执行MapReduce作业时为啥需要保证指定的输出目录不存在。
3. 将作业运行所需要的资源文件（作业JAR包，配置文件，输入分片）复制到一一起（一个以作业ID命名的目录下）。
4. 调用submitApplication()方法提交作业。​
### 作业的初始化
1. 首先资源管理器会将作业请求传递给YARN调度器  
2. 调度器分配一个容器
3. 资源管理器在节点管理器的管理下在容器中启动application master​​
4. application master的主类MRAppMaster会创建多个簿记对象来跟踪作业的进度。
5. 接收输入分片
6. 为每个分片创建map任务以及确定reduce任务，并且分配任务ID
### 任务的分配
application master会为创建的任务向资源管理器请求容器，先是为map任务请求资源，后为reduce任务请求资源。
为map任务分配资源的时候需要考虑到数据本地化的局限，会尽量保证运行的map任务所需要的数据块存储在当前机器或者当前机架中，这样会极大的节省带宽资源。而reduce任务则不存在这个限制。
### 任务的执行
1. 资源管理器为任务分配好容器后，application master就通过与节点管理器通信启动容器。
2. 在运行任务之前，会将任务所需要的资源本地化
3. 运行任务
### 进度和状态的更新
&nbsp;&nbsp;&nbsp;&nbsp;任务在运行的过程中，会对其精度保持追踪，对与map任务，其任务进度就是已经处理的输入所占总输入的比例。对与reduce任务来讲就比较复杂了，因为这个部分包含资源复制阶段、排序阶段和reduce阶段三个阶段，每个阶段都占整个完成比例的1/3，也就是说当我们完成reduce的一半的时候这个时候的进度应该为5/6。
&nbsp;&nbsp;&nbsp;&nbsp;对与状态的更新，客户端会每秒轮询一次application master以接收最新的任务状态。
### 作业的完成
当application master收到作业最后一个任务已经完成的通知后，便把作业的状态设置为“成功”

最后我大致画了一个图，仅供参考。
![](https://g-blog.oss-cn-beijing.aliyuncs.com/image/63-01.jpg)